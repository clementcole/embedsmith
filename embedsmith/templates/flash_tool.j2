#!/usr/bin/env python3
"""
Flash Tool for ${project_name}
Author: ${author}
Version: ${version}

A tool for flashing firmware to the target device.
"""

import argparse
import sys
import os
import time
import serial
import subprocess
from pathlib import Path
from typing import Optional, List


class FlashTool:
    def __init__(self, port: str = None, baudrate: int = 115200):
        self.port = port
        self.baudrate = baudrate
        self.serial_conn = None
        
    def find_serial_port(self) -> Optional[str]:
        """Attempt to find the correct serial port automatically."""
        possible_ports = []
        
        if sys.platform.startswith('win'):
            possible_ports = [f'COM{i}' for i in range(1, 21)]
        elif sys.platform.startswith('linux'):
            possible_ports = [f'/dev/ttyUSB{i}' for i in range(10)] + \
                            [f'/dev/ttyACM{i}' for i in range(10)]
        elif sys.platform.startswith('darwin'):  # macOS
            possible_ports = [f'/dev/tty.usbserial-*', f'/dev/tty.usbmodem*']
        
        for port in possible_ports:
            try:
                with serial.Serial(port, self.baudrate, timeout=1):
                    return port
            except (serial.SerialException, OSError):
                continue
                
        return None
    
    def connect(self, port: str = None) -> bool:
        """Connect to the target device."""
        if port:
            self.port = port
        elif not self.port:
            self.port = self.find_serial_port()
            
        if not self.port:
            print("Error: No serial port specified or found")
            return False
            
        try:
            self.serial_conn = serial.Serial(
                self.port,
                self.baudrate,
                timeout=2,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                bytesize=serial.EIGHTBITS
            )
            print(f"Connected to {self.port} at {self.baudrate} baud")
            return True
        except serial.SerialException as e:
            print(f"Error connecting to {self.port}: {e}")
            return False
    
    def disconnect(self):
        """Disconnect from the target device."""
        if self.serial_conn and self.serial_conn.is_open:
            self.serial_conn.close()
            print("Disconnected")
    
    def flash_binary(self, firmware_path: str) -> bool:
        """Flash binary firmware to the target."""
        if not os.path.exists(firmware_path):
            print(f"Error: Firmware file not found: {firmware_path}")
            return False
            
        print(f"Flashing firmware: {firmware_path}")
        
        # This is a placeholder for actual flashing logic
        # In practice, you would use:
        # - OpenOCD for JTAG/SWD programming
        # - st-flash for ST-Link
        # - esptool for ESP32
        # - bossac for Arduino, etc.
        
        try:
            # Example using subprocess (adjust for your programmer)
            result = subprocess.run([
                'openocd',
                '-f', 'interface/stlink-v2.cfg',
                '-f', 'target/stm32f4x.cfg',
                '-c', f'program {firmware_path} verify reset exit'
            ], capture_output=True, text=True)
            
            if result.returncode == 0:
                print("Flash successful!")
                return True
            else:
                print(f"Flash failed: {result.stderr}")
                return False
                
        except FileNotFoundError:
            print("Error: OpenOCD not found. Please install OpenOCD or use appropriate flasher.")
            return False
    
    def reset_device(self) -> bool:
        """Reset the target device."""
        if not self.serial_conn:
            print("Error: Not connected to device")
            return False
            
        try:
            # Toggle DTR to reset (works for many development boards)
            self.serial_conn.dtr = True
            time.sleep(0.1)
            self.serial_conn.dtr = False
            time.sleep(0.5)
            print("Device reset")
            return True
        except Exception as e:
            print(f"Error resetting device: {e}")
            return False
    
    def monitor_serial(self, duration: int = 0):
        """Monitor serial output from the device."""
        if not self.serial_conn:
            print("Error: Not connected to device")
            return
            
        print("Starting serial monitor (Ctrl+C to stop)...")
        start_time = time.time()
        
        try:
            while True:
                if duration > 0 and (time.time() - start_time) > duration:
                    break
                    
                if self.serial_conn.in_waiting > 0:
                    line = self.serial_conn.readline().decode('utf-8', errors='ignore').strip()
                    if line:
                        print(line)
                time.sleep(0.01)
                        
        except KeyboardInterrupt:
            print("\nSerial monitor stopped")
        except Exception as e:
            print(f"Error in serial monitor: {e}")


def main():
    parser = argparse.ArgumentParser(description='Flash tool for embedded project')
    parser.add_argument('firmware', nargs='?', help='Firmware file to flash')
    parser.add_argument('--port', '-p', help='Serial port')
    parser.add_argument('--baudrate', '-b', type=int, default=115200, help='Baud rate')
    parser.add_argument('--reset', '-r', action='store_true', help='Reset device')
    parser.add_argument('--monitor', '-m', action='store_true', help='Monitor serial output')
    parser.add_argument('--duration', '-d', type=int, default=0, help='Monitor duration in seconds (0 = infinite)')
    
    args = parser.parse_args()
    
    tool = FlashTool(args.port, args.baudrate)
    
    if not tool.connect():
        sys.exit(1)
    
    try:
        if args.firmware:
            if not tool.flash_binary(args.firmware):
                sys.exit(1)
        
        if args.reset:
            tool.reset_device()
        
        if args.monitor:
            tool.monitor_serial(args.duration)
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
    finally:
        tool.disconnect()


if __name__ == '__main__':
    main()